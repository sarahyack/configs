/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => UnusedBlockIdRemover
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  excludedExtensions: [".excalidraw.md"]
};
var UnusedBlockIdRemoverSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Excluded file extensions").setDesc("Add file extensions (e.g., .excalidraw.md) separated by commas to exclude from scanning.").addTextArea((text) => {
      text.setPlaceholder("Enter extensions separated by commas").setValue(this.plugin.settings.excludedExtensions.join(", ")).onChange(async (value) => {
        this.plugin.settings.excludedExtensions = value.split(",").map((ext) => ext.trim());
        await this.plugin.saveSettings();
      });
    });
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(plugin, unusedBlockIds) {
    super(plugin.app);
    this.plugin = plugin;
    this.unusedBlockIds = unusedBlockIds;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: `Unused Block IDs: (${this.unusedBlockIds.length})` });
    const list = contentEl.createEl("ul");
    this.unusedBlockIds.forEach((item) => {
      const li = list.createEl("li");
      const link = li.createEl("a", {
        text: item.id,
        href: "#"
      });
      link.addEventListener("click", (e) => {
        e.preventDefault();
        this.plugin.openFileAtBlockId(item.file, item.id, item.lineNumber);
      });
      li.createEl("span", { text: ` in file: ${item.file}` });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Delete all").onClick(() => {
      this.plugin.deleteUnusedBlockIds(this.unusedBlockIds);
      this.close();
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close()));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var UnusedBlockIdRemover = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new UnusedBlockIdRemoverSettingTab(this.app, this));
    this.addCommand({
      id: "scan-vault",
      name: "Scan vault",
      callback: () => this.findUnusedBlockIds()
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async findUnusedBlockIds() {
    const loadingNotice = new import_obsidian.Notice("Searching for unused block IDs...", 0);
    try {
      const excludedExtensions = this.settings.excludedExtensions.filter((ext) => ext);
      const files = this.app.vault.getMarkdownFiles().filter((file) => {
        return excludedExtensions.length === 0 || !excludedExtensions.some((ext) => file.path.endsWith(ext));
      });
      const blockIds = /* @__PURE__ */ new Map();
      const blockIdReferences = /* @__PURE__ */ new Set();
      for (const file of files) {
        const content = await this.app.vault.cachedRead(file);
        this.collectBlockIdsAndReferences(content, file.path, blockIds, blockIdReferences);
      }
      const unusedBlockIds = Array.from(blockIds.entries()).flatMap(([key, blockIdArray]) => {
        return blockIdArray.filter((item) => {
          const referenceKey = `${item.file}#${item.id}`;
          return !blockIdReferences.has(referenceKey);
        });
      });
      loadingNotice.hide();
      if (unusedBlockIds.length === 0) {
        new import_obsidian.Notice("No unused block IDs found.");
      } else {
        new ConfirmationModal(this, unusedBlockIds).open();
      }
    } catch (error) {
      loadingNotice.hide();
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  collectBlockIdsAndReferences(content, filePath, blockIds, blockIdReferences) {
    const lines = content.split("\n");
    const blockIdRegex = /(?:\s|^)\^([\w-]+)$/;
    const blockIdRefRegex = /\[\[(.*?)#\^([\w-]+)\s*(\|.*?)?\]\]/g;
    lines.forEach((line, index) => {
      var _a, _b;
      const match = line.match(blockIdRegex);
      if (match && this.isValidBlockId(match[1])) {
        const blockId = match[1];
        const blockIdKey = `${filePath}#${blockId}`;
        if (!blockIds.has(blockIdKey)) {
          blockIds.set(blockIdKey, []);
        }
        (_a = blockIds.get(blockIdKey)) == null ? void 0 : _a.push({
          id: blockId,
          file: filePath,
          line: line.trim(),
          lineNumber: index
        });
      }
      let refMatch;
      while ((refMatch = blockIdRefRegex.exec(line)) !== null) {
        const refFilePath = (_b = this.app.metadataCache.getFirstLinkpathDest(refMatch[1], filePath)) == null ? void 0 : _b.path;
        if (refFilePath) {
          const blockRefKey = `${refFilePath}#${refMatch[2]}`;
          blockIdReferences.add(blockRefKey);
        }
      }
    });
  }
  isValidBlockId(id) {
    return /^[\w-]+$/.test(id);
  }
  async deleteUnusedBlockIds(unusedBlockIds) {
    const loadingNotice = new import_obsidian.Notice("Deleting unused block IDs...", 0);
    let totalRemoved = 0;
    const blockIdsByFile = unusedBlockIds.reduce((acc, item) => {
      if (!acc[item.file]) {
        acc[item.file] = [];
      }
      acc[item.file].push(item);
      return acc;
    }, {});
    try {
      for (const [filePath, blockIds] of Object.entries(blockIdsByFile)) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian.TFile) {
          await this.app.vault.process(file, (content) => {
            const lines = content.split("\n");
            let fileChanged = false;
            blockIds.forEach((blockId) => {
              const lineIndex = blockId.lineNumber;
              if (lineIndex >= 0 && lineIndex < lines.length) {
                const blockIdRegex = new RegExp(`\\s*\\^${blockId.id}$`);
                if (blockIdRegex.test(lines[lineIndex])) {
                  lines[lineIndex] = lines[lineIndex].replace(blockIdRegex, "");
                  totalRemoved++;
                  fileChanged = true;
                }
              }
            });
            return fileChanged ? lines.join("\n") : content;
          });
        }
      }
      loadingNotice.hide();
      new import_obsidian.Notice(`Removed ${totalRemoved} unused block IDs.`);
    } catch (error) {
      loadingNotice.hide();
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  async openFileAtBlockId(filePath, blockId, lineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      const leaf = this.app.workspace.getLeaf();
      await leaf.openFile(file, {
        eState: { line: lineNumber }
      });
    }
  }
};


/* nosourcemap */